import matplotlib.pyplot as plt
import csv
import numpy as np


def import_frdm_data(filename):
    '''Imports a dataset generated from the FRDM-KL03 running Warp firmware (using option 'z' to save the accelerometer data)'''

    # Import file
    with open(filename, 'r') as file:
        data = file.readlines()

    t = []
    x = []
    y = []
    z = []

    # Process imported data. Check it has the right form (FRDM data should have 9 columns), and cast to integer
    for datum in data:
        datum = datum.split(",")
        datum = [x.strip() for x in datum]
        if len(datum) != 9:
            continue

        try:
            datum = [int(x) for x in datum]
        except ValueError:
            continue

        # TODO - Change to make t actual time
        t.append(datum[0])
        x.append(datum[3])
        y.append(datum[4])
        z.append(datum[5])

    return t, x, y, z


def import_phyphox(filename):
    '''Imports a csv file generated by a Phyphox accelerometer experiment'''

    t = []
    x_raw = []
    y_raw = []
    z_raw = []

    with open(filename, "r") as file:
        data_reader = csv.reader(file, delimiter=",", quotechar="|")
        for row in data_reader:
            try:
                t.append(float(row[0]))
                x_raw.append(float(row[1]))
                y_raw.append(float(row[2]))
                z_raw.append(float(row[3]))
            except ValueError:
                pass
    return t, x_raw, y_raw, z_raw


def plot_3_axis(t, x, y, z):
    '''Plots all three axes of accelerometer data'''

    plt.figure()
    plt.subplot(311)
    plt.plot(t, x)
    plt.ylabel("x acceleration")

    plt.subplot(312)
    plt.plot(t, y)
    plt.ylabel("y acceleration")

    plt.subplot(313)
    plt.plot(t, z)
    plt.ylabel("z acceleration")

    plt.show()


def plot_extremal(t, data, steps=None):
    '''Plots acceleration data as well as the max, min and threshold for each sampling window'''

    if steps is not None:
        plt.plot(t, data['acc'], t, data['max'], t, data['min'], t, data['thr'], t, steps * (np.mean(data['acc'])))
    else:
        plt.plot(t, data['acc'], t, data['max'], t, data['min'], t, data['thr'])
    plt.legend(['acc', 'max', 'min', 'thr'])
    plt.show()


def plot_3_axis_extremal(t, x, y, z):
    '''Plots all 3 axes of acceleration data as well as the max, min and threshold for each sampling window'''
    plt.figure()
    plt.subplot(311)
    plt.plot(t, x['acc'], t, x['max'], t, x['min'], t, x['thr'])
    # plt.legend(['acc', 'max', 'min', 'thr'])
    plt.ylabel('x')

    plt.subplot(312)
    plt.plot(t, y['acc'], t, y['max'], t, y['min'], t, y['thr'])
    plt.ylabel('y')

    plt.subplot(313)
    plt.plot(t, z['acc'], t, z['max'], t, z['min'], t, z['thr'])
    plt.ylabel('z')

    plt.show()


def generate_distributions(t, data, N):
    '''Returns the mean and variance of distributions formed of N datapoints of data'''

    means = []
    errors = []
    new_time = []
    for i in range(data.shape[0] // N):
        means.append(np.mean(data[i * N: (i + 1) * N]))
        errors.append(np.var(data[i * N: (i + 1) * N]))
        new_time.append(t[i * N])

    return np.array(new_time), np.array(means), np.array(errors)


def generate_samples(data, N):
    '''Generates N samples drawn from the data distributions. Used as inputs to MCMC'''

    mean = data['means']
    cov = np.diag(data['vars'])

    return np.random.multivariate_normal(mean, cov, N)


def low_pass(data, order=4):
    '''Low pass filter data'''

    filtered_data = []
    for i in range(len(data) - order + 1):
        datum = 0
        for j in range(order):
            datum += data[i + j]
        filtered_data.append(datum / order)
    return np.array(filtered_data)


def mark_extremes(data, start, end, sample_rate):
    '''Compute the max, min and threshold for each sampling window'''

    extremes_start = start + sample_rate
    extremes_end = end + sample_rate * 2

    data['max'][extremes_start:extremes_end] = np.max(data['acc'][start:end])
    data['min'][extremes_start:extremes_end] = np.min(data['acc'][start:end])
    data['thr'][extremes_start:extremes_end] = (data['max'][extremes_start] + data['min'][extremes_start]) / 2
    data['pkpk'][extremes_start:extremes_end] = data['max'][extremes_start] - data['min'][extremes_start]
    return data


def find_max_axis(x, y, z, index):
    '''Returns the maximum activity axis at given index'''

    maxx = x['pkpk'][index]
    maxy = y['pkpk'][index]
    maxz = z['pkpk'][index]

    if maxx > maxy and maxx > maxz:
        return x
    elif maxy > maxx and maxy > maxz:
        return y
    else:
        return z


def count_steps(t, x, y, z, samples_per_dist):
    '''Pedometer algorithm. Returns number of steps counted'''

    # Order of low pass filtering
    order = 5
    # Window to remove N samples from start and end (this is noise before the user started walking)
    window = int(1500 / samples_per_dist)

    t = np.array(t[window:len(t) - order + 1 - window])
    x['acc'] = low_pass(x['means'][window:-window], order)
    y['acc'] = low_pass(y['means'][window:-window], order)
    z['acc'] = low_pass(z['means'][window:-window], order)

    plot_3_axis(t, x['acc'], y['acc'], z['acc'])
    plt.show()

    # Initialise max, min, thr and pkpk arrays
    x['max'] = np.zeros(t.shape)
    x['min'] = np.zeros(t.shape)
    x['thr'] = np.zeros(t.shape)
    x['pkpk'] = np.zeros(t.shape)

    y['max'] = np.zeros(t.shape)
    y['min'] = np.zeros(t.shape)
    y['thr'] = np.zeros(t.shape)
    y['pkpk'] = np.zeros(t.shape)

    z['max'] = np.zeros(t.shape)
    z['min'] = np.zeros(t.shape)
    z['thr'] = np.zeros(t.shape)
    z['pkpk'] = np.zeros(t.shape)

    sample_rate = int(650 / (samples_per_dist + order))
    count = sample_rate - 1
    start = 0
    steps = 0

    old_sample = {'t': t[0],
                  'x': x['acc'][0],
                  'y': y['acc'][0],
                  'z': z['acc'][0]}

    max_axis_array = np.zeros(t.shape)

    for i in range(sample_rate, t.shape[0]):
        current_sample = {'t': t[i],
                          'x': x['acc'][i],
                          'y': y['acc'][i],
                          'z': z['acc'][i]}

        # Each sampling period reset the max, min, thr and pkpk values
        if count == sample_rate - 1:
            end = i

            x = mark_extremes(x, start, end, sample_rate)
            y = mark_extremes(y, start, end, sample_rate)
            z = mark_extremes(z, start, end, sample_rate)

            start = end

        max_axis = find_max_axis(x, y, z, i)

        # Check there is a crossing of threshold from negative to positive
        if current_sample[max_axis['name']] < max_axis['thr'][i] < old_sample[max_axis['name']]:
            steps += 1

        if max_axis['name'] == 'x':
            max_axis_array[i] = 0
        elif max_axis['name'] == 'y':
            max_axis_array[i] = 1
        elif max_axis['name'] == 'z':
            max_axis_array[i] = 2
        else:
            max_axis_array[i] = -1

        # Increment count (and reset to 0 if we reach the end of a sampling period)
        count = (count + 1) % sample_rate
        old_sample = current_sample

    # print(steps)

    plot_3_axis_extremal(t, x, y, z)

    return steps


def monte_carlo(t, x_dict, y_dict, z_dict, N, fn, samples_per_dist=20):
    '''Performs Monte Carlo integration on input distributions and returns the samples of step counts'''

    x_samples = generate_samples(x_dict, N)
    y_samples = generate_samples(y_dict, N)
    z_samples = generate_samples(z_dict, N)

    step_samples = np.zeros(x_samples.shape[1])

    for i in range(x_samples.shape[1]):
        curr_x = x_dict
        curr_x['means'] = x_samples[i, :]

        curr_y = y_dict
        curr_y['means'] = y_samples[i, :]

        curr_z = z_dict
        curr_z['means'] = z_samples[i, :]

        step_samples[i] = fn(t, curr_x, curr_y, curr_z, samples_per_dist)

    return step_samples


# Import data
t, x_raw, y_raw, z_raw = import_frdm_data("20 steps moving frdm.txt")

# Set up a dictionary for each axis. The keys are:
# name: name of axis
# raw: raw data imported
# means: means of distributions generated
# vars: variances of distributions generated
# acc: low passed data (means)
# max: maximum value of acc for a given sample period
# min: minimum value of acc for a given sample period
# thr: threshold for a given sample period (max + min) / 2
# pkpk: peak to peak for a given period (max - min)

x = {'name': 'x',
     'raw': np.array(x_raw, dtype=np.float64)}
y = {'name': 'y',
     'raw': np.array(y_raw, dtype=np.float64)}
z = {'name': 'z',
     'raw': np.array(z_raw, dtype=np.float64)}

samples_per_dist = 20

_, x['means'], x['vars'] = generate_distributions(t, x['raw'], samples_per_dist)
_, y['means'], y['vars'] = generate_distributions(t, y['raw'], samples_per_dist)
t, z['means'], z['vars'] = generate_distributions(t, z['raw'], samples_per_dist)

N = 10000

print(count_steps(t, x, y, z, samples_per_dist))
samples = monte_carlo(t, x, y, z, N, count_steps)
print(np.mean(samples))
print(np.var(samples))

plt.hist(samples, bins=[15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])
plt.title("Monte Carlo simulation of pedometer")
plt.xlabel("Steps")
plt.ylabel("Count")
plt.show()
